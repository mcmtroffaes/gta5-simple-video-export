; global options
enable = true

; logging options
; possible values are trace, debug, info, warn, err, critical, off
; best performance with flush_on = off but log may not be written until game quits
; when reporting bugs, please set level = trace and flush_on = trace
[log]
level = info
flush_on = off

; options for raw uncompressed output
; default folder is ${scriptfolder} (the \sve subfolder in the game folder)
; set output_folder to \\.\pipe\ to send the raw uncompressed output to named pipes
; set output_folder to an actual folder to save the raw uncompressed output to actual files
; note that the uncompressed files are very big (178MB per second for 1080p at 60fps)
[raw]
;folder = \\.\pipe\
folder = ${scriptfolder}
video_filename = sve-${timestamp}-video.yuv
audio_filename = sve-${timestamp}-audio.raw

; client process for filtering raw output
; if you set the output_folder to \\.\pipe\ then this will be executed in a separate thread
; if not, check the logs after export for command to process the raw uncompressed files
; the different args variables are simply concatenated when the process is called,
; so you don't need to put everything on one line
[client]
; batch file for running the full client command to process the raw uncompressed output
; run this at the start of the export to process raw pipes (if raw folder is \\.\pipe)
; run this anytime after the export to process raw files
batchfile = ${scriptfolder}\sve-${timestamp}-client.bat

; full path to the client executable (don't change this unless you know what you are doing)
executable = ${scriptfolder}\ffmpeg.exe

; general arguments (don't change this unless you know what you are doing)
args0 = -y

; video input (don't change this unless you know what you are doing)
args1 = -f rawvideo -pix_fmt ${video_format} -s:v ${width}x${height}
args2 = -r ${framerate_numerator}/${framerate_denominator} -i "${video_path}"

; audio input (don't change this unless you know what you are doing)
args3 = -f ${audio_format} -ar ${audio_rate} -ac ${audio_num_channels} -i "${audio_path}"

; filters (optional)
args4 =
args5 =

; video codec
; lossless ffv1               -c:v ffv1
; lossless x264               -c:v libx264 -crf 0
; lossless x264 fast & large  -c:v libx264 -preset ultrafast -crf 0
; lossless x264 slow & small  -c:v libx264 -preset ultraslow -crf 0
; near lossless fast & large  -c:v libx264 -preset ultrafast -crf 2
; near lossless slow & small  -c:v libx264 -preset ultraslow -crf 2
; high quality                -c:v libx264 -crf 18
; medium quality              -c:v libx264 -crf 23
; low quality                 -c:v libx264 -crf 28
args6 = -c:v ffv1

; audio codec
; lossless compressed         -c:a flac
; lossless uncompressed       -c:a pcm_s16le
; lossy, high quality         -c:a aac -b:a 384k
; lossy, low quality          -c:a aac -b:a 96k
args7 = -c:a flac

; full path to output file
; extension determines container format
; .mkv and .avi support most codecs
; for .mp4 use x264 for video and aac for audio
args8 = "${scriptfolder}\sve-${timestamp}.mkv"

; uncomment if you would like to redirect ffmpeg output to a log file
;args9 = 2> "${scriptfolder}\sve-${timestamp}-ffmpeg-log.txt"

; maps media foundation video subtype GUID to ${video_format} variable
; https://msdn.microsoft.com/en-us/library/windows/desktop/aa370819(v=vs.85).aspx
[videosubtypes]
; MFVideoFormat_NV12
3231564E-0000-0010-8000-00AA00389B71 = nv12
; MFVideoFormat_I420
I420 = yuv420p
; MFVideoFormat_IYUV
IYUV = yuv420p

; maps media foundation audio subtype GUID to ${audio_format} variable
; https://msdn.microsoft.com/en-us/library/windows/desktop/aa372553(v=vs.85).aspx
[audiosubtypes]
; MFAudioFormat_PCM
; use s16le in case of 16 bits per sample (normally this is the case)
; may have to use u8 in case of 8 bits per sample
00000001-0000-0010-8000-00AA00389B71 = s16le
