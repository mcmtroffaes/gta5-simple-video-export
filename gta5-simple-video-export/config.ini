; global options
enable = true

; logging options
; possible values are trace, debug, info, warn, err, critical, off
; best performance with flush_on = off but log may not be written until game quits
; when reporting bugs, please set level = trace and flush_on = trace
[log]
level = info
flush_on = off

; options for raw uncompressed output
; default folder is ${scriptfolder} (the \sve subfolder in the game folder)
; set output_folder to \\.\pipe\ to send the raw uncompressed output to named pipes
; set output_folder to an actual folder to save the raw uncompressed output to actual files
; note that the uncompressed files are very big (178MB per second for 1080p at 60fps)
[raw]
folder = \\.\pipe\
;folder = ${scriptfolder}
video_filename = sve-${timestamp}-video.yuv
audio_filename = sve-${timestamp}-audio.raw

; client process for filtering raw output
; if you set the output_folder to \\.\pipe\ then this will be executed in a separate thread
; if not, check the logs after export for command to process the raw uncompressed files
; the different args variables are simply concatenated when the process is called,
; so you don't need to put everything on one line
[client]
; batch file for running the full client command to process the raw uncompressed output
; run this at the start of the export to process raw pipes (if raw folder is \\.\pipe)
; run this anytime after the export to process raw files
batchfile = ${scriptfolder}\sve-${timestamp}-client.bat

; full path to the client executable (don't change this unless you know what you are doing)
executable = ${scriptfolder}\ffmpeg.exe

; general arguments (don't change this unless you know what you are doing)
args0 = -y

; audio input (don't change this unless you know what you are doing)
args1 = -f ${audio_format} -ar ${audio_rate} -ac ${audio_num_channels} -i "${audio_path}"

; video input (don't change this unless you know what you are doing)
args2 = -f rawvideo -pix_fmt ${video_format} -s:v ${width}x${height}
args3 = -r ${framerate_numerator}/${framerate_denominator} -i "${video_path}"

; filters (optional)
args4 =
args5 =
args6 =

; audio codec
; lossless uncompressed    -c:a pcm_s16le
; lossless compressed      -c:a flac
; high quality             -c:a aac -b:a 384k
; medium quality           -c:a aac -b:a 192k
; low quality              -c:a aac -b:a 96k
args7 = -c:a flac

; video codec
; lossless compressed      -c:v ffv1
; high quality             -c:v libx264 -crf 18
; medium quality           -c:v libx264 -crf 23
; low quality              -c:v libx264 -crf 28
args8 = -c:v ffv1

; full path to output file
; extension determines container format
; .avi and .mkv support most codecs
; for .mp4 use libx264 for video and aac for audio
args9 = "${scriptfolder}\sve-${timestamp}.avi"

; maps media foundation audio subtype GUID to ${audio_format} variable
; https://msdn.microsoft.com/en-us/library/windows/desktop/aa372553(v=vs.85).aspx
; normally you don't need to edit this section
[audioformats]
; MFAudioFormat_PCM
; use s16le in case of 16 bits per sample (normally this is the case)
; may have to use u8 in case of 8 bits per sample
00000001-0000-0010-8000-00AA00389B71 = s16le

; maps media foundation video subtype GUID to ${video_format} variable
; the values below map it to the ffmpeg pixel format as passed by -pix_fmt
; https://msdn.microsoft.com/en-us/library/windows/desktop/aa370819(v=vs.85).aspx
; normally you don't need to edit this
; if you get unknown video format errors, you have to add an entry here
[videoformats]
; MFVideoFormat_NV12
3231564E-0000-0010-8000-00AA00389B71 = nv12
; MFVideoFormat_I420
30323449-0000-0010-8000-00AA00389B71 = yuv420p
; MFVideoFormat_IYUV
56555949-0000-0010-8000-00AA00389B71 = yuv420p
; MFVideoFormat_YUY2
32595559-0000-0010-8000-00AA00389B71 = yuyv422
; MFVideoFormat_RGB24
00000014-0000-0010-8000-00AA00389B71 = rgb24
